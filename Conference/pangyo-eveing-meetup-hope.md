# 내 마음대로 되지 않는 테스트코드, 꼭 작성해야 할까? (희망편)

### # 01 테스트 코드 왜 작성해야 할까?

테스트를 하는 궁극적인 목표 → 지속적인 성장 / 품질 개선  
그러나 서비스가 커져갈수록 테스트 비용은 증가한다.

#### **테스트 코드의 이점**

**1. 테스트 자동화를 통한 테스트 비용 절감**  

테스트 코드는 손으로, 눈으로 기능 검증하는 것 보다 **더 빠르고**  
**자주** 수행할 수 있기 때문에 제품을 **자주 배포**할 수 있게 해준다.  

**2. 개발단계에서도 많은 이점을 발휘**  

예를 들어, 주문서를 생성 로직 (복잡한 주문서 검증 로직 + 주문서 생성/저장) 에  
쿠폰을 사용할 수 있는지 검증하는 ‘쿠폰 유효성 검증 로직’ 을 쿠폰 객체에 구현하였다고 가정하자.  

테스트 코드가 없는 이런 상황에 추가한 내용을 테스트 하는 방법으로는  
기존에 동작하고 있던 로직에 추가한 로직을 포함시켜서 API 호출할 수 있다.  
→ 그러나 이런 테스트 방식은, **다른 수정된 부분들도 같이 테스트가 된다는 문제점이 존재한다.**

이렇게 더 넓은 범위를 테스트 하게 되면 원하지 않는 결과가 나왔을때 실패한 이유를 명확히 알 수 없지만  
테스트 코드를 작성하게 되면, **부분적으로 테스트 할 수있기 때문에 코드 결함을 빠르게 인지할 수 있다**.  

**3. 검증된 최신 명세의 역할**  

배포 전 개발 단계나 CI 에서 반복적으로 수행이 가능하다.  
빠른 피드백과 지속적인 패드백을 통한 안정성, 생산성 향상될 뿐더러  
이해하기 힘든 복잡한 코드의 의도를 알 수도 있게 된다.  

⇒ 이는 미래의 나, 신규 입사자 또는 동료에게 테스트로 **검증된 최신 명세의 역할**  

**4. 심리적 안정감**

개발을 진행할때 리팩토링을 하거나 신규기능 추가 시,  
기존에 존재하던 테스트의 성공 여부를 보며 작성한 코드의 신뢰감 형성  

### # 02 좋은 테스트 코드의 기준

#### **2-1. 빠른 테스트**  
빠른 피드백과 지속적인 패드백을 통한 **안정성, 생산성 향상** ⇒ **자주, 반복 수행**  
테스트 속도가 빠를수록 빠른 패드백을 받을 수 있고, 빠르게 결함을 인지할 수 있다.  

**어떻게 하면 테스트 속도를 빠르게 할 수 있을까?**  
ㄴ 단위 테스트 비중 높이기! → **대체로 단위테스트가 통합테스트보다 빠르다**  

\* 단위 테스트란?  
백엔드 특성상, 다른 서버나 브라우저로 부터 요청을 받고 다른 서버에게 요청을 보내거나  
DB 에 저장하는 의부 의존성들과 상호작용 하는 경우가 많은데 여기서 그런것들과 상호작용  
하지 않는, 백엔드 서버 내부에서만 수행되는 테스트를 단위테스트 /  그 외는 통합 테스트라고 정의.  

예시 코드(주문서 생성 로직) :  

```javascript
export class OrderService {
	async placeOrder(userId: number, productId: number, paymentPrice: number) {
		const user = await this.userRepository.getById(userId);
		const product = await this.userRepository.getById(productId);
		
		// 복잡한 주문서 검증로직
		
		const order = Order.create({
			userId: user.id,
			productId: product.id,
			title: product.title,
			regularPrice: product.price,
			paymentPrice: product.price
		});
		
		await this.orderRepository.save(order);
	}
}
```

여기서 가장 중요하게 테스트 되어야 할 부분은 주문서 검증 로직(도메인 로직)과 주문서 생성 로직이다.  
하지만 이 로직을 테스트 하기 위해선 외부 의존성인 DB 와 함께 테스트를 해야하는 상황.  
이렇게 되면 통합 테스트를 수행해야 하지만 두 로직을 분리 하여 `OrderFactory` 를 만들수도 있다.  

```jsx
export class OrderFactory {
	craete(user: User, product: Product) {
		// 복잡한 검증 로직 및 금액 계산로직
		
		return Order.create({
			userId: user.id,
			productId: product.id,
			title: product.title,
			regularPrice: product.price,
			paymentPrice,
		})
	}
}
```

이렇게 분리를 한다면 복잡한 검증이나 금액 계산, 주문서 생성하는 로직이  
DB 의 외부 의존성을 갖지 않아 단위 테스트만으로도 검증이 가능해 진다.  
그로인해 복잡한 로직들과 함께 통합 테스트로 이루어졌던 OrderService 테스트 케이스들을  
OrderFactory 에 있는 단위테스트 들로 분리 할 수 있게 되어진 것이다.  

결과적으로 기존 통합 테스트로 이루어지던 부분을 단위 테스트로 분리 → 좀 더 빠르게 테스트 가능  

### **2-2. 쉽게 깨지지 않는 테스트**  

테스트 코드도 코드이다보니 계속해서 유지보수 / 관리 비용이 든다.  

간단하게 리팩토링을 진행했는데 테스트가 계속 실패한다고 가정해보자.  
리팩토링이 제대로 진행 되었으면 기존 기능은 정상 수행될 것 → 테스트가 깨지는게 더 이상함  

그러나 이런 상황이 지속되면 **테스트의 대한 신뢰가 떨어지고, 테스트가 실패하더라도 무감각해지게** 된다.  
실제 기능에 문제가 있어도 그런 무감각성 때문에 인지를 제대로 하지 못하게 되는 것이다.  
그렇게 테스트를 신뢰하지 못하게 된다면 코드를 수정할때 최소한의 코드만 변경하게 되기도 한다.  

**그렇다면 어떤 점이 테스트를 쉽게 깨지게 만들까?**

앞에서 본 주문서 생성 로직으로 다시 한번 예시를 들어보자면,  
이번에는 단위 테스트 비중을 높이기 위해서 `Mocking` 을 통한 테스트를 할 수 있다.  

\* Mocking 이란?  
테스트 더블의 한 종류로 특정 메서드를 호출했을때, 정해진 값을 반환하는 정도로 사용하는 것  

\* 테스트 더블이란?
테스트 목적으로 실제 사용되는 객체를 교체하는 것을 의미한다. 테스트하기 힘든 외부 API 나   
이런 부분들을 가짜 객체로 교체해서 테스트 가능한 범위까지 테스트를 할 수 있도록 도와주는 것  

위 예제에서 Mocking 을 진행한다면, DB 에 의존적인 유저나 상품을 조회하고  
주문서 저장하는 부분을 단위 테스트로 변경할 수 있다.  

테스트 코드 예시 :

```jsx
it('유저는 상품을 주문할 수 있다', async() => {
	// given
	const user = createUser();
	const product = createProduct();
	
	userRepository.getById.mockResolvedValue(user); /* Mocking */
	productRepository.getById.mockResolvedValue(product); /* Mocking */
	
	// when
	await orderService.placeOrder(
		user.id,
		product.id,
		product.price
	)
	
	// then
	// 저장에 대한 검증 수행
})
```

이렇게 `Mocking` 을 사용해서 미리 정의한 유저나 프로덕트 객체를 반환하도록 하는 것이다.  

결과적으로 이렇게 DB 없이 Mocking 을 통해서 테스트를 진행했을때,  
단위 테스트이기 때문에 좀 더 빠르게 수행되니까 성공적이라고 생각할 수 있다.  

기존 주문서 생성 로직에서 유저를 조회하던 메서드가 `getValidById` 로 변경되었다고 생각을 해보자.  

```jsx
export class OrderService {
	async placeOrder(userId: number, productId: number, paymentPrice: number) {
		const user = await this.userRepository.getValidById(userId);
		// ...
	}
}
```

기존 테스트 코드에서는 [ `getById` 를 호출했을때, 어떤 유저가 반환될 것이다 ] 라는 부분을  
`Mocking` 하고 있었기 때문에 이 테스트는 실패하게 될 것이다.  

하지만 변경 후 기능이 정상동작 함에도 테스트가 실패하는 원인은  
모킹을 사용하게 되면 앞에서 어떤 객체와 상호작용 하는지 테스트에 명시하다보니  
**상세구현이 드러나게 되는데 → 이렇게 되면 변경에 취약해진다**.  

클라이언트의 관점에서 생각해보자.  
OrderService 를 호출하는 클라이언트는 내부에서 userRepository 에서 유저를 조회한다.  
이런 내용들이 아닌 전달한 파라미터에 맞게 주문서를 생성 / 저장하길 기대할 것이다.  

따라서 Mocking 을 사용한 테스트가 아닌 통합 테스트를 통해 세부 구현을  
노출하지 않고 테스트를 작성하게 된다면 깨지지 않는 테스트가 될 수 있다.  

즉, 세부 구현을 테스트하기 보다는 클라이언트가 목표로 하는 행위의 결과를  
테스트하는 것이 좀 더 쉽게 깨지지 않는 테스트를 작성하는 데 도움을 줄 것이다.  

### **2-3. 회귀 방지를 잘해주는 테스트**

여기서 말하는 회귀는 코드가 변경되었을 때, 기능이 의도한대로 동작하지 않는 것을 의미한다.  
회귀 방지를 잘 해주는 테스트 ==  코드 변경 시 발생하는 문제를 잘 알려주는 테스트  

**이를 만족하는 테스트**

**1. 많은 코드를 실행하는 테스트**  
   **”통합 테스트가 단위테스트 보다 회귀방지를 잘해준다”**   
    많은 코드를 실행할수록 더 많은 범우를 커버하기 때문에, 버그가 발생한걸 인식하는데 도움이 된다.
    
**3. 코드 복잡도가 높은 부분에 작성된 테스트**    
    회귀 발생 가능성이 높은 부분에 대해 테스트를 하는 것.  
    코드 복잡도 증가 → 개발 단계에서 실수나 문제가 발생할 여지가 높아지기 때문에,  
    코드 복잡도가 높은 부분에 테스트를 작성하면 회귀를 방지할 수 있다.  


이렇게 전체적으로 좋은 테스트 코드라는 내용을 정리해보면,  

- 빠**른 테스**트 → 단위 테스트 비중을 높이자!  
- **쉽게 깨지지 않는 테스트** → 클라이언트가 목표하는 행위의 결과를 테스트하자!  
- **회귀 방지를 잘해주는 테스트**  
    
    → 많은 코드를 실행하는 테스트를 하자!  
    → 코드의 복잡도가 높은 곳에 작성된 테스트를 하자!
    

단위 테스트는 통합 테스트에 비해 당연히 빠르지만, 부분 범위만 테스트하기 때문에 회귀 방지성이 낮아지게 된다.  
반면 통합 테스트는 외부 의존성을 테스트하기 때문에 테스트 속도가 느리지만 더 넓은 범위를 커버할 수 있다.  

그렇다 보니 **단위 테스트와 통합 테스트가 테스트하는 범위와 비중을 잘 나눠서 테스트 하는게 정말 중요**하다.  

---

연사자 정보 : 김명일,  현) 인프랩 백엔드 개발자
