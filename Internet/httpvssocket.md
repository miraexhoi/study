# **HTTP 통신 vs Socket 통신 차이**

### HTTP 통신 (단방향 통신, 비연결성)

기본적으로 클라이언트의 요청이 있을 때만 서버가 응답하고 연결 종료

HTTP을 통해 양방향 통신 하는 방법
1. **Http Polling** 

**:** 클라이언트가 지속적으로 서버로  request를 하여 이벤트를 수신하는 방식

가장 간단한 방법이지만, 지속적으로 서버에 요청을 던지기 때문에 클라이언트가 많아지면 서버의 부담(서버의 오버헤드)이 급증하게 된다.
- request connection을 맺고 끊는것에도 자원이 들어가는데 불필요한 request와 connection이 생성된다.
- 클라이언트에서 실시간정도의 빠른 응답을 기대하기 어렵다.
1. **Http Long Polling**

: 클라이언트에서 서버로 request를 보내고 기다리다가 서버에서 해당 클라이언트로 이벤트가 생겨 response가 오면 연결이 종료,  
이후 클라이언트에서는 곧바로 다시 request를 보내서 서버의 다음 이벤트를 기다리는 방식이다.
- polling 방식보다는 서버의 부담이 줄겠지만 클라이언트로 보내는 이벤트들의 시간간격이 좁아 메세지가 쏟아질 경우 polling 방식과 같아짐
- 서버에서 클라이언트에게 응답을 보내면 곧바로 요청이 들어오기 때문에 다수의 클라이언트 요청을 처리하더라도 곧바로 다수의 클라이언트가 서버로 connection을 요청하면서 서버의 부담이 급증하게 된다.
1. **Http Streaming**

**:** 서버는 클라이언트로부터 request를 받으면, response을 주고 연결을 끊지 않고. 이벤트가 발생함에 따라 클라이언트로 전송하는 방식인데 역시나 근본적인 원인인 해결하지 못한다.

쉽게 말하면, 내가 원하는 데이터에 비해  동반되는 데이터들이 너무 많고, 지속적으로 이 데이터를 포함해야 하며 맺고 끊는 연결을 계속하는 등 리소스의 낭비가 크다.

### Socket 통신 (양방향 통신, 연결성)

Server와 Client가 지속적으로 연결을 유지하고 양방향으로 통신

(주로 채팅 같은 실시간성을 요구하는 서비스에서 많이 사용)

### WebSocket 동작 과정

- handshaking으로 HTTP 요청을 사용해 서버와 클라이언트 간의 연결
- 서버와 클라이언튼 간의 웹소켓 연결이 정상적으로 이루어 진다면 일정 시간 이후 HTTP 연결은 자동으로 끊어짐
- 이후 ws(80), wss(443) 프로토콜을 통해 양방향 통신

### Pub/Sub 브로커 (Stomp)

텍스트기반의 메세징 프로콜로 메세지전송을 효율적으로 하기 위해 나온 프로토콜  
pub/sub 구조로 되어있어 메시지를 발송하고, 메시지를 받아 처리하는 부분이 확실히 명시 가능

또한 브로커는 메시지 브로커, 이벤트 브로커 2가지로 나뉠 수 있는데,  
**메시지 브로커는 이벤트 브로커의 역할을 할 수 없지만 이벤트 브로커는 메시지 브로커의 역할을 할 수 있다.**


### **메시지 브로커 (RabbitMQ, Redis ...)**

대규모 메시지 기반 **미들웨어** 아키텍쳐에서 사용됨  
메시지를 받아서 적절히 처리하면 **__짧은 시간내에 메시지가 삭제되는 특징__** (데이터 손실의 위험)  


### **이벤트 브로커 (kafka, kinesis...)**

이벤트 또는 메시지라고 불리는 정보를** 하나만 보관**하고 **인덱스를 통해 개별 엑세스를 관리**
**필요한 시간동안 이벤트를 관리** / 메시지 브로커와 다르게 **이벤트가 삭제되지 않는다는 특징**

\+ 서비스에서 발생하는 이벤트를 DB에 저장하듯이 이벤트 **브로커의 큐에 저장**
