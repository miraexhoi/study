# N+1 문제란?

특정 객체를 대상으로 수행한 쿼리가 해당 객체가 가지고 있는  
연관관계 또한 조회하게 되면서 __N번의 추가적인 쿼리가 발생하는 문제__

근본적인 원인은 관계형 데이터베이스와 객체지향 언어간 패러다임 차이로 인해 발생

객체는 연관관계를 통해 레퍼런스를 가지고 있으면 언제든지 메모리 내에서 **Random Access**를 통해  
연관 객체에 접근할 수 있지만 RDB의 경우 **Select 쿼리**를 통해서만 조회가 가능  

→ N+1 문제가 발생하면 **쿼리가 배수적으로 증가하면서 DB에 큰 부담이 발생하게 되고 장애 요인, 지연율 또한 크게 증가**

### N+1 예시

**기본 엔티티 가정**
- Team A, Team B, Team C 3개의 Team 엔티티가 존재
- 각 팀 엔티티에는 멤버들이 속해있다고 가정 (멤버가 비어있는 팀 x)

  
**비지니스 요구 사항**

**각 팀에 속한 멤버들의 닉네임**을 조회 가능

```
public List<String> findAllTeamMemberNicknames() {
    return teamRepository.findAll().stream()
            .flatMap(team -> team.getMembers().stream())
            .map(Member::getNickname)
            .toList();
}
```

- **TeamRepository의 findAll**로 모든 Team(Team A, Team B, Team C) 조회
- 각 팀의 모든 멤버의 닉네임 **Member의 getNickname()** 으로 수집하여 반환

**테스트 코드 → 쿼리 결과**

```
@Test
@DisplayName("모든 팀에 속한 닉네임 목록을 가져올 때, 쿼리를 검사한다.")
void inspect_query_findAllTeamMemberNicknames() {
    // when & then
    teamService.findAllTeamMemberNicknames();
}
```

```
SELECT t1_0.id, t1_0.name, FROM team t1_0 (모든 팀 조회 쿼리)
SELECT m1_0.team_id, m1_0.id, m1_0.nickname FROM member m1_0 WHERE m1_0.team_id=? (각 팀에 속한 모든 멤버 조회 쿼리)
SELECT m1_0.team_id, m1_0.id, m1_0.nickname FROM member m1_0 WHERE m1_0.team_id=? (각 팀에 속한 모든 멤버 조회 쿼리)
SELECT m1_0.team_id, m1_0.id, m1_0.nickname FROM member m1_0 WHERE m1_0.team_id=? (각 팀에 속한 모든 멤버 조회 쿼리)
… (멤버가 N명이면 N개의 추가 쿼리 발생)
```

 

모든 팀 조회 쿼리 1개와 각 팀에 속한 모든 멤버 조회 쿼리 3개가 발생 (N+1)
- **모든 팀 조회 쿼리 : 1**
- **각 팀(Team A, B, C)에 속한 모든 멤버 조회 쿼리 : N (3개 - 팀 개수만큼)**  

  
만약 팀이 3개가 아니라 100개, 1000개가 된다면,  
모든 팀을 조회할 때 1개 쿼리가 아닌 팀의 개수만큼 1 + 100개, 1 + 1000개의 쿼리가 발생

**N+1 뭔인 분석**

1. 모든 팀 조회 쿼리
- **TeamRepository.findAll()** 에 의한 모든 팀 조회 쿼리
- **select * from team** 

2. 각 팀에 속한 모든 멤버 조회 쿼리
- **개발자가 직접적으로 호출하지 않은** , 1번에서 조회한 각 팀에 속한 멤버 조회 쿼리
- **select * from member where team_id = ?**

해당 쿼리가 발생하는 이유로는 **JPA가 Team 엔티티를 맵핑**하는 과정과 밀접한 관련

1. 먼저 **'select * from team'** 을 통해 가져온 테이블의 컬럼과 Team 엔티티를 맵핑한다.
2. **'select * from member where team_id = ?'** 을 통해 조회한 Team 엔티티에 속한 Member 엔티티를 맵핑한다.

먼저 Team 테이블에서 컬럼들을 Team 엔티티로 맵핑하고, 이후에 조회한 Team에 해당하는 FK를 가진 Member 테이블의 컬럼들을 조회하여 Member 엔티티를 맵핑하여 최종 Team 엔티티를 가져오는 것

### N+1 문제의 해결 방법 (fetch join)

JPA의 구현체인 Hibernate에서는 제공해준 N+1 문제의 해결책 중 **outer fetch join** 선택

이전 예시로 들었던 Team-Member 에서 JPQL로 fetch join을 사용한 예:

outer join으로 명시되어 있지만, 기본 동작은 inner join으로 동작하고 outer join으로 동작하려면 left join을 명시해야함

```
--INNER JOIN
select t from Team t join fetch t.members

--OUTER JOIN
select t from Team t left join fetch t.members
```

```
public interface TeamRepository extends JpaRepository<Team, Long> {

    @Query("select t from Team t join fetch t.members")
    List<Team> findAllWithInnerFetchJoin();
    
    @Query("select t from Team t left join fetch t.members")
    List<Team> findAllWithOuterFetchJoin();
}
```

위 JPQL 사용 예시에 대한 테스트 코드 쿼리 실행 결과:

```
@Test
@DisplayName("페치 조인으로 모든 팀 조회 시 쿼리를 관찰한다.")
void inspect_query_fetch_join_findAll() {
    teamRepository.findAllWithInnerFetchJoin();
    teamRepository.findAllWithOuterFetchJoin();
}
```

```
SELECT t1_0.id, m1_0.team_id, m1_0.id, m1_0.nickname, t1_0.name FROM team t1_0 JOIN member m1_0 on t1_0.id=m1_0.team_id

SELECT t1_0.id, m1_0.team_id, m1_0.id, m1_0.nickname, t1_0.name FROM team t1_0 LEFT JOIN member m1_0 on t1_0.id=m1_0.team_id
```

- 모두 Team 엔티티를 가져올 때 Member를 join해서 가져오기 때문에 Member를 가져오는 추가 조회 쿼리 발생 x
- 따라서 N+1 문제가 해결 (차이점은 사진처럼 inner join & outer left join에 차이)
