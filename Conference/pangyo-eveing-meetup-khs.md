# 내 마음대로 되지 않는 테스트코드, 꼭 작성해야 할까? (현실편)

### #01 현실적인 테스트 코드 작성법

**목차 1. 단위 테스트**  

- 무엇을 테스트할 것인가
- **엣지 케이스**는 어디까지 커버해야 하는가 통합 테스트

**목차 2. 통합 테스트**  

- **의존성**을 다루는 방법
- **데이터베이스** 모킹하지 않기

인프런 팀은 TDD 가 아닌, 개발 후 테스트 코드를 추가하는 방식을 사용한다.  
예를 들어, 명세된 회원가입 기능 을 구현한다고 가정해보자.  

`Controller` 쪽에서 사용자 요청을 처리하고 **요청값을 받아 파싱/검증**해서 `Service` 로 넘겨준다.  
그러면 `Service` 쪽 코드에서는 앞에서 받은 값으로 **주요 비지니스 로직을 수행**하게 됨.  

Service 계층에서 필요한 DB 조회/저장 같은 로직은 `Repository` 를 이용해서 이루어 지도록 함.  
마지막으로 서비스 계층에서 반환한 **최종 결과 데이터를 받아 Controller 에서 가공 및 응답한다.**  

### 무엇을 테스트할 것인가?

각 객체들은 회원가입이라는 목적을 달성하기 위해 필요한 일들을  
`Controller`, `Service`, `Entity`, `Repository` 로 나눠서 구현한다.  

그렇다면 테스트 코드는 나눠진 기능명세를 자연스럽게 표현하도록 구현하면 된다.  
여기서 중요한건, **테스트 구현 세부사항이 드러나도록 작성하면 안된다**.  
**구현 세부사항에 집착할수록 깨지기 쉬운 테스트**가 된다.  

Repository 를 목킹 처리해서 이메일 증복 검사에 대한 테스트 코드 예시:  

```jsx
// bad
	it('받은 이메일에 해당하는 계정이 데이터베이스에 이미 존재하는지 확인한다.', async () => {
		// given
		const mockUserApiRepository = mock<UserApiRepository>();
		const service = new UserApiService(mockUserApiRepository, new Crypto());
		const email = 'test@email.com';
		
		// when
		await service.signUp('nickname', email, 'password');
		
		// then
		expect(mockUserApiRepository.findByEmail).toBeCalledTimes(1); /* Mocking */
		expect(mockUserApiRepository.findByEmail).toBeCalledWith(email); /* Mocking */
	}
);
```

`findByEmail` 이란 메서드를 특정 이메일로 몇번이나 호출했냐는 테스트는 중간과정에 속하는 구현 세부사항.  
이렇게 구현 세부사항을 노출하고 검증하게 되면 깨지기 쉬운 테스트가 되기 때문에 좋지 못한 테스트가 된다.  

만약에 구현부에서 `findByEmail` 을 두번 호출한다고 해서 회원가입에 실패하지는 않을 것.  
하지만 이렇게 검증한 다음 호출 횟수가 달라졌기 떄문에 테스트가 깨지게 되는 문제가 발생하는 것이다.  

대신에 이런 구현 세부사항 보다는 이 기능이 어떤 사실을 포함하고 있는지에 대해 자연스럽게 읽히도록 검증하고,  
호출 후에 최종 상태를 검증해야 리팩토링 대상에도 좋은 테스트 코드를 작성할 수 있다.  

이렇게 테스트 명세는 항상 중간 과정이나 구현 세부사항이 아닌 테스트 하려는 메서드를 호출했을때   
변화하는 최종 상태나 출력 결과를 표현하는 명세를 작성해야 한다.  

### **테스트 작성 순서**

**작은 단위나 의존성이 거의 없는 영역을 먼저 테스트 하는 것이 좋다.**  
작은 단위에 대해서 테스트를 먼저 진행하게 되면 상위 레이어나 더 큰 단위에서  
해당 코드를 사용할 때 검증한 내용이라고 생각하고 신경쓸 필요가 없어지게 되기 때문이다.  
( 테스트 작성 시에 신경 쓸 영역을 줄여보려는 시도 )  

**주로 단위 테스트의 대상이 되는 영역은 도메인 규칙과 복잡한 알고리즘을 담고 있는 경우가 많다.**  
따라서 이런 도메인 규칙을 담고 있는 단위 테스트를 간단하게 구성하는 것이 좋은데  
단위 테스트는 테스트 비용이 낮고, 의존성이 없기 때문에 비교적 작성하기도 쉬운 편에 속하게 됨.    
⇒ 엣지 케이스들을 자세하게 검증하는 것이 좋다.

### 엣지 케이스는 어디까지 검증해야 할까?

1. 의미없는 테스트를 많이 테스트 하게되면 중요한 테스트를 알아보기 힘들게 만들고,   
불필요한 테스트 들로 인하여 테스트 속도 저하의 원인이 된다.  

1. 그렇다고 간단하고 쉬운 케이스(성공하는 테스트)만 테스트하면  
어떤 상황에서 예외가 발생하는지 예측이 힘들고 관련된 버그도 방지 할 수도 없다.  

따라서 우리는 이 둘의 중간지점에서 균형을 잡아야 한다. → 경계값  

\* 경계값이란?  
특정한 범위가 주어지면 양 끝 / 끝에서 아주 약간 벗어난 값을 주로 테스트 하는 방식  

### 통합 테스트

통합 테스트는 단위 테스트와 다루게 주로 외부 의존성들과 결합되어 있는 경우가 대부분이다.  
따라서 통합 테스트는 의존성 관리와의 싸움이라고 할 수도 있다.  

먼저 회원가입의 서비스 코드를 살펴보자 :

```jsx
async signUp(nickname: string, email: string, password: string): Promise<User> {
	const duplicatedEmail = await this.userApiRepository.findByEmail(email); /* 의존성 */
	
	if (duplicatedEmail) {
		throw new Error('이미 사용중인 이메일입니다.');
	}
	
	const hashedPassword = this.crypto.encrypt(password); /* 의존성 */
	const user = User.signUp(nickname, email, hashedPassword);
	
	return await this.userApiRepository.save(user);
}
```

이 코드에는 유저 엔티티의 저장/조회를 위한 의존성과 암호화 모듈에 대한 두 가지 의존성이 존재하는데  
이런 의존성을 철회하는 방법 중 하나로는, 테스트 더블을 사용하는 방식이 있다.  

책 ‘단위 테스트’ 에서 발췌한 내용으로 `의존성` 에 대해 조금 더 자세히 알아보자.  

1. **공유 의존성 (shared dependency)**  
    테스트 간에 공유되고 서로의 결과에 영향을 미칠 수 있는 수단을 제공하는 의존성  
    
2. **비공개 의존성 (private dependency)**  
공유하지 않는, 주로 시스템 내부 객체간의 의존성  
구현 세부사항에 속하는 경우가 많음

4. **프로세스 의부 의존성 (out-of-process dependency)**  
어플리케이션 외부에서 실행되는 의존성  
아직 메모리에 없는 데이터에 대한 프록시  

단위 테스트의 관점에서 봤을때 여기서 테스트 더블의 대상은 **공유 의존성**과 **프로세스 외부 의존성**이다.  

![image](https://github.com/user-attachments/assets/662bc71c-c67c-4095-a6dc-f74b71a58810)


시스템 외부에 테스트 더블을 사용하는 것이 당연해 보이겠지만, DB 는 적절한 위치가 아니다.  

그 이유는 … **데이터베이스는 시스템 외부에서 접근 불가능하고,**  
**테스트하려는 시스템 네부에서만 완전히 제어가 가능한 구현 세부사항이기 때문이다.**  
→ 전체를 접근할 수 있고 외부 제어가 차단된 의존성을 관리 의존성이라고 한다.  

**어떤 의존성이 테스트 더블을 사용하기에 적합할까?**  

예를 들어 외부에서 접근 가능한 메일 서버가 있다.  
( = 외부 변경사항 때문에 깨질 가능성 높음 )  
또한 실제 의존성을 사용하게 되면 테스트를 진행할 때마다  
메일이 날라가기 때문에 이런 상황에는 테스트 더블을 사용하는 것이 적합하다.  

”**외부에서 접근이 가능한 비관리 의존성은 외부 시스템의 변화로 인해 테스트가 영향받을 수 있음”**  

**테스트 더블로 교체해야 할 대상**  
**= 프로세스 외부의 공유 의존성**이고  
   외부에서 접근이 가능한 **비관리 의존성**이 경우  

다음으로는 위 코드에서 암호화 모듈을 부분만 살펴보자.  
```jsx
this.crypto.encrypt(password);
```

내부에서 객체 간에 통신만 존재(외부 통신 x)하는 비공개 통신이자 구현 세부사항이라고 볼 수 있다.  
별도에 테스트 더블을 고려하지 않고 있는 객체를 그대로 사용하는 편이 리팩토링을 고려했을때 더 나은 선택지이다.  
그렇다면 별도에 테스트 더블 없이 있는 그대로 객체를 사용하고 **최종 상태를 검증**하면 된다.  

### #02 현실적인 고민

> **“테스트 코드를 작성할 시간이 없어요”**

#### 테스트 코드 작성 **시간 확보**  

![image](https://github.com/user-attachments/assets/405bf98d-cda9-408f-9ff6-08accdf5baa2)

100의 시간이 주어지면 70의 시간은 70점짜리 코드를 만드는 데 쓰고, 나머지 30을 테스트 코드 작성  

![image](https://github.com/user-attachments/assets/9657dbdf-e976-4bf5-9238-3389bf79e144)

자동차를 만들때 바퀴부터 만드는게 아니라 굴러가는 스케이트 보드 부터 만들어라!  
코드 작성도 마찬가지로 뼈대를 만들고 살을 붙이는 방식이 좋다.  
**테스트 코드 작성 시간 == 놓친 기능 파악 + 리팩토링 + 버그 수정 시간**  

그 외에 방법은 Ai 추천 ⭐️⭐️⭐️ ( ex. “테스트 코드 만들어줘” )  

#### 테스트 코드 작성 **속도**

1. **가성비 있는 테스트 작성하기**  
    
   ![image](https://github.com/user-attachments/assets/e8d16393-3381-4fd5-8edf-33328ec87c7e)

    
    - 3 사분면은 테스트 코드의 의미가 거의 없다.  
        너무 명확 / 간단하고 중요한 의존성을 가지고 있지만 그 영역마저   
        상위 레이어에서 한번 호출하는 것으로 확보가 된다.  
    - 1 사분면의 코드는 리팩토링을 통해 2,3 사분면의 코드로 보내야 한다.  
3. **커버리지에 집착하지 않기**  
    
   ![image](https://github.com/user-attachments/assets/607a0833-0cff-441c-8c46-b74a43dfeda6)

    
    간단한 예로, 이 테스트 코드는 이 코드의 모든 라인과 모듈을 통과하기 때문에 커버리지가 100% 이다.  
    이렇게 모든 결과를 예측할 수 있다고 해서 버그에서 안전한 것은 아니다.  

    물론 위는 typescript 의 도움을 받아 버그를 방지할 수는 있겠지만 사용자 입력값을 받는 경우는 아니다.  
    대부분의 버그는 사용자가 예측할 수 없는 입력값으로 인해 발생하고,  
    이렇게 커버리지가 100% 라고 하더라도 항상 커버되지 못한 엣지 케이스가 발생하게 된다.  
    
    ⇒ 따라서 높은 커버리지에 집착하기 보다는 앞에 가성비 있는 테스트를 권장한다.  
    

#### 테스트 다이어트  

**제거 대상 테스트  
== 사용하지 않는 메서드에 테스트만 남아 있는 경우  
리팩토링 하면서 제거되지 않은 중복된 테스트**
